# -*- coding: utf-8 -*-
"""CellAgent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14UD8lpIQPyQlB9jTAIYdOvFnJ7YNmvz2

# CellAgent Replicator ðŸ§¬

This project is a simplified implementation inspired by the paper:

ðŸ“„ **CellAgent: An LLM-driven Multi-Agent Framework for Automated Single-cell Data Analysis**  
[arXiv:2407.09811](https://arxiv.org/abs/2407.09811)

---

## Overview

The goal of this project is to replicate the core logic of **CellAgent**, a framework that automates scRNA-seq (single-cell RNA sequencing) data analysis using a **multi-agent system powered by Large Language Models (LLMs)**.

The system simulates how a human expert would plan, code, and evaluate an analysis taskâ€”entirely through LLM interaction and prompt engineering.

---

## Implemented Components

This implementation includes the following core agents:

- **Planner**: Receives a natural language task description and breaks it into structured step-by-step instructions.
- **Executor**: Generates executable Python code for each step using available tools.
- **Evaluator**: Compares multiple code solutions and selects the best one based on the task objective.

In addition, two auxiliary modules have been implemented:

- **Memory Control**: Passes contextual code between steps to maintain consistency.
- **Tool Retriever**: Supplies brief documentation about available tools to help the Executor make informed decisions.

# --- Implementation ---

In this section the following libraries are imported:

*   **openai**: to use openai API
*   **json**: to work with json objects
*   **userdata**: to have access to the API key secretely

Then, the API is configurated
"""

###
!pip install openai #==0.28

# Libraries importation
import openai # to call API
import json # to work with json data
from google.colab import userdata # to access secret variables

# API configuration
openai.api_key = userdata.get('API-KEY')

"""In this section Planner is defined via the *planner_task_decomposition* function:

Input:
* **user_task**: the task given by the user to CellAgent [text]
* **dataset_description**: information regarding the dataset uploaded by the user, it can also be left empty by the user [text]

Output:
* **task_plan**: a list of subtasks (title and description) in wich the assigned task is divided [list of dictionaries]
"""

# PLANNER

def planner_task_decomposition(user_task, dataset_description=""):
    """
    Planner: Decomposes a task in a certain number of subtasks
    """
    prompt = f"""
    Act as an expert in scRNA-seq analysis. The user will provide a description of the task.
    Your job is to decompose the task into an ordered list of steps (max 8), each with a title and a short description.

    Dataset description: {dataset_description}
    User task: {user_task}

    Respond in the following JSON format:
    [
        {{"step": 1, "title": "Step Name", "description": "Short description of the step"}},
        ...
    ]

    """

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3
    )

    try:
        content = response["choices"][0]["message"]["content"] # extracts json from gpt answer
        task_plan = json.loads(content) # converts json to dict list
        return task_plan # returns dict list (list of tasks)
    except Exception as e:
        print("Error during evaluator assessment:", e)
        return []

"""In this section Executor is defined via the *executor_generate_code* function:

Input:
* **step_descritpion**: description of the subtask, ideated by Planner [string]
* **available_tools**: list of tools (libraries or other instruments) that can be accessed by Executor to generate better code [list]
* **context_code**: code from the previous iteration that can provide the model some context to provide a better result

Output:
* a tuple that contains a script and a text analysis of the provided solution
"""

# EXECUTOR

def executor_generate_code(step_description, available_tools, context_code=""):
    """
    Executor: generates Python code for each step, considering the available tools
    """
    tool_docs = { # !aggiungi tool rilevanti
    "Scanpy": "Python library for analyzing single-cell RNA-seq data, supports preprocessing, clustering, visualization, etc.",
    "CellTypist": "Python tool for automatic cell type annotation using pretrained models.",
    "ScType": "R-based tool for cell type annotation based on known marker genes.",
    "Harmony": "R tool for batch effect correction in single-cell data.",
    "scVI": "Deep generative model for batch correction and dimensionality reduction.",
    "Slingshot": "Trajectory inference tool that models lineage relationships.",
    "PAGA": "Partition-based graph abstraction used for trajectory and clustering analysis.",
    "Combat": "Batch correction tool based on empirical Bayes methods."}

    tools_str = ", ".join(available_tools) # converts list to a string of "," separated items

    # Build a formatted string containing the available tools and their descriptions
    tool_info_lines = []
    for tool in available_tools:
        descrizione = tool_docs.get(tool, "N/A")
        riga = f"{tool}: {descrizione}"
        tool_info_lines.append(riga)
    tool_info = "\n".join(tool_info_lines)

    prompt = f"""
    You are an expert in scRNA-seq analysis and Python programming.
    Your task is to generate Python code for the following step in the analysis:

    Step: {step_description}

    Available tools: {tools_str}

    Available tools (with descriptions): {tool_info}

    Previous context: {context_code}

    Respond with a JSON in the following format:
    {{
        "analysis": "Explanation of what the code does",
        "code": "<executable Python code>"
    }}

    """

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.4
    )

    try:
        content = response["choices"][0]["message"]["content"] # extracts json from gpt answer
        result = json.loads(content) # converts json to dict list
        return result.get("code", ""), result.get("analysis", "") # returns tuple (script, analysis)
    except Exception as e:
        print("Error during evaluator assessment:", e)
        return "", ""

"""In this section Evaluator is defined via the *evaluator_select_best_code* function:

Input:
* **step_description**: description of the subtask, ideated by Planner [string]
* **code_trials**: list of the possible scripts generated by Executor [list]

Output:
* a tuple containing the index of the chosen script and a string that explains why it was chosen
"""

# EVALUATOR
def evaluator_select_best_code(step_description, code_trials, user_goal="accurate result"):
    """
    Evaluator: analyzes multiple scripts for each subtask and chooses the better one
    """
    prompt = f"""
    You are an expert in scRNA-seq analysis. You need to evaluate several Python code solutions
    for the following task: "{step_description}".

    The user's goal is: {user_goal}.

    Here are the generated code alternatives:
    """

    for i, code in enumerate(code_trials):
        prompt += f"\n\n--- Code #{i+1} ---\n{code}"

    prompt += """
    Evaluate which code is the most suitable, and briefly explain why.
    Respond in the following JSON format:
    {{
        "selected_index": <index of the best code, starting from 1>,
        "justification": "Reason for your choice"
    }}

    """

    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3
    )

    try:
        content = response["choices"][0]["message"]["content"] # extracts json from gpt answer
        result = json.loads(content) # converts json to dict list
        return result.get("selected_index", None), result.get("justification", "") # returns tuple (index of the chosen script alternative, choice justification)
    except Exception as e:
        print("Error during evaluator assessment:", e)
        return None, ""

"""The *function run_cellagent_task* defines the interaction between the three agents for the solution of a given task.

Input:
* **user_task**: the task given by the user to CellAgent [text]
* **dataset_description**: information regarding the dataset uploaded by the user, it can also be left empty by the user [text]
* **available_tools**: list of tools (libraries or other instruments) that can be accessed by Executor to generate better code [list]
* **steps_to_run**: list of indexes of the steps of Planner's plan that have to be executed
* **trials_per_step**: number of scripts Executor has to generate for each step [number]

Output:
* **results**: a list of information regarding each step, in particuar the code to execute the task and a justification for the choice [list of dictionaries]
"""

# MAIN FUNCTION

def run_cellagent_task(user_task, dataset_description, available_tools, steps_to_run=None, trials_per_step=2):
    # prints the input
    print("\nTask:", user_task)
    print("Dataset:", dataset_description)
    print("Available tools:", ", ".join(available_tools))

    # calls Planner
    plan = planner_task_decomposition(user_task, dataset_description)
    if not plan:
        print("No plan was generated.")
        return

    results = []
    memory_code = "" # memory control
    for step in plan:
        if not steps_to_run or step["step"] in steps_to_run:
            print(f"\nStep {step['step']}: {step['title']}")
            print(step['description'])
        # calls Executor
        trial_codes = []
        for _ in range(trials_per_step):                                             # memory control
            code, _ = executor_generate_code(step["description"], available_tools, context_code=memory_code)
            if code:
                trial_codes.append(code)

        if not trial_codes:
            print("No code was generated.")
            continue
        # calls Evaluator
        best_index, justification = evaluator_select_best_code(step["description"], trial_codes)
        if best_index is None or best_index < 1 or best_index > len(trial_codes):
            print("No selection was done by the Executor.")
            continue

        best_code = trial_codes[best_index - 1]
        print("Selected code:")
        print(best_code)
        print("Motivation:", justification)

        results.append({
            "step": step["step"],
            "title": step["title"],
            "description": step["description"],
            "code": best_code,
            "justification": justification
        })

        # memory control
        memory_code += f"\n# Step {step['step']}: {step['title']}\n" + best_code + "\n"

    return results

"""# --- Testing ---"""

# CELL TYPE ANNOTATION
!pip install scanpy

filename = "pbmc.h5ad"
import scanpy as sc
adata = sc.read_h5ad(filename)
print(f"Dataset loaded: {adata.n_obs} cells, {adata.n_vars} genes.")

from google.colab import userdata
import openai
openai.api_key = userdata.get("API-KEY")

user_task = "Annotate the cell types in the dataset."
dataset_description = "Human peripheral blood mononuclear cells (PBMC), single-cell RNA-seq."
available_tools = ["Scanpy", "CellTypist", "ScType"]

results = run_cellagent_task(
    user_task=user_task,
    dataset_description=dataset_description,
    available_tools=available_tools,
    steps_to_run=None,
    trials_per_step=2
)

print("\n\n Final selected code per step:")
for result in results:
    print(f"\nStep {result['step']}: {result['title']}")
    print(result['code'])
    print("Justification:", result['justification'])

# BATCH CORRECTION

# TRAJECTORY INFERENCE